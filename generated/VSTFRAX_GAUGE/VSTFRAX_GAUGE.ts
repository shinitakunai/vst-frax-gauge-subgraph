// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class DefaultInitialization extends ethereum.Event {
  get params(): DefaultInitialization__Params {
    return new DefaultInitialization__Params(this);
  }
}

export class DefaultInitialization__Params {
  _event: DefaultInitialization;

  constructor(event: DefaultInitialization) {
    this._event = event;
  }
}

export class LockedStakeMaxMultiplierUpdated extends ethereum.Event {
  get params(): LockedStakeMaxMultiplierUpdated__Params {
    return new LockedStakeMaxMultiplierUpdated__Params(this);
  }
}

export class LockedStakeMaxMultiplierUpdated__Params {
  _event: LockedStakeMaxMultiplierUpdated;

  constructor(event: LockedStakeMaxMultiplierUpdated) {
    this._event = event;
  }

  get multiplier(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class LockedStakeMinTime extends ethereum.Event {
  get params(): LockedStakeMinTime__Params {
    return new LockedStakeMinTime__Params(this);
  }
}

export class LockedStakeMinTime__Params {
  _event: LockedStakeMinTime;

  constructor(event: LockedStakeMinTime) {
    this._event = event;
  }

  get secs(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class LockedStakeTimeForMaxMultiplier extends ethereum.Event {
  get params(): LockedStakeTimeForMaxMultiplier__Params {
    return new LockedStakeTimeForMaxMultiplier__Params(this);
  }
}

export class LockedStakeTimeForMaxMultiplier__Params {
  _event: LockedStakeTimeForMaxMultiplier;

  constructor(event: LockedStakeTimeForMaxMultiplier) {
    this._event = event;
  }

  get secs(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class MaxVeFXSMultiplier extends ethereum.Event {
  get params(): MaxVeFXSMultiplier__Params {
    return new MaxVeFXSMultiplier__Params(this);
  }
}

export class MaxVeFXSMultiplier__Params {
  _event: MaxVeFXSMultiplier;

  constructor(event: MaxVeFXSMultiplier) {
    this._event = event;
  }

  get multiplier(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class OwnerChanged extends ethereum.Event {
  get params(): OwnerChanged__Params {
    return new OwnerChanged__Params(this);
  }
}

export class OwnerChanged__Params {
  _event: OwnerChanged;

  constructor(event: OwnerChanged) {
    this._event = event;
  }

  get oldOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class OwnerNominated extends ethereum.Event {
  get params(): OwnerNominated__Params {
    return new OwnerNominated__Params(this);
  }
}

export class OwnerNominated__Params {
  _event: OwnerNominated;

  constructor(event: OwnerNominated) {
    this._event = event;
  }

  get newOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class Recovered extends ethereum.Event {
  get params(): Recovered__Params {
    return new Recovered__Params(this);
  }
}

export class Recovered__Params {
  _event: Recovered;

  constructor(event: Recovered) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class RewardPaid extends ethereum.Event {
  get params(): RewardPaid__Params {
    return new RewardPaid__Params(this);
  }
}

export class RewardPaid__Params {
  _event: RewardPaid;

  constructor(event: RewardPaid) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get reward(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get token_address(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get destination_address(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class StakeLocked extends ethereum.Event {
  get params(): StakeLocked__Params {
    return new StakeLocked__Params(this);
  }
}

export class StakeLocked__Params {
  _event: StakeLocked;

  constructor(event: StakeLocked) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get secs(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get kek_id(): Bytes {
    return this._event.parameters[3].value.toBytes();
  }

  get source_address(): Address {
    return this._event.parameters[4].value.toAddress();
  }
}

export class WithdrawLocked extends ethereum.Event {
  get params(): WithdrawLocked__Params {
    return new WithdrawLocked__Params(this);
  }
}

export class WithdrawLocked__Params {
  _event: WithdrawLocked;

  constructor(event: WithdrawLocked) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get kek_id(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get destination_address(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class veFXSPerFraxForMaxBoostUpdated extends ethereum.Event {
  get params(): veFXSPerFraxForMaxBoostUpdated__Params {
    return new veFXSPerFraxForMaxBoostUpdated__Params(this);
  }
}

export class veFXSPerFraxForMaxBoostUpdated__Params {
  _event: veFXSPerFraxForMaxBoostUpdated;

  constructor(event: veFXSPerFraxForMaxBoostUpdated) {
    this._event = event;
  }

  get scale_factor(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class VSTFRAX_GAUGE__calcCurCombinedWeightResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class VSTFRAX_GAUGE__earnedResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class VSTFRAX_GAUGE__getRewardResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class VSTFRAX_GAUGE__getRewardForDurationResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class VSTFRAX_GAUGE__lockedStakesResult {
  value0: Bytes;
  value1: BigInt;
  value2: BigInt;
  value3: BigInt;
  value4: BigInt;

  constructor(
    value0: Bytes,
    value1: BigInt,
    value2: BigInt,
    value3: BigInt,
    value4: BigInt
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromFixedBytes(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    return map;
  }
}

export class VSTFRAX_GAUGE__lockedStakesOfResultValue0Struct extends ethereum.Tuple {
  get kek_id(): Bytes {
    return this[0].toBytes();
  }

  get start_timestamp(): BigInt {
    return this[1].toBigInt();
  }

  get liquidity(): BigInt {
    return this[2].toBigInt();
  }

  get ending_timestamp(): BigInt {
    return this[3].toBigInt();
  }

  get lock_multiplier(): BigInt {
    return this[4].toBigInt();
  }
}

export class VSTFRAX_GAUGE__rewardPerTokenResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class VSTFRAX_GAUGE extends ethereum.SmartContract {
  static bind(address: Address): VSTFRAX_GAUGE {
    return new VSTFRAX_GAUGE("VSTFRAX_GAUGE", address);
  }

  bridgeFXS(): Address {
    let result = super.call("bridgeFXS", "bridgeFXS():(address)", []);

    return result[0].toAddress();
  }

  try_bridgeFXS(): ethereum.CallResult<Address> {
    let result = super.tryCall("bridgeFXS", "bridgeFXS():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  calcCurCombinedWeight(
    account: Address
  ): VSTFRAX_GAUGE__calcCurCombinedWeightResult {
    let result = super.call(
      "calcCurCombinedWeight",
      "calcCurCombinedWeight(address):(uint256,uint256,uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return new VSTFRAX_GAUGE__calcCurCombinedWeightResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_calcCurCombinedWeight(
    account: Address
  ): ethereum.CallResult<VSTFRAX_GAUGE__calcCurCombinedWeightResult> {
    let result = super.tryCall(
      "calcCurCombinedWeight",
      "calcCurCombinedWeight(address):(uint256,uint256,uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new VSTFRAX_GAUGE__calcCurCombinedWeightResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  combinedWeightOf(account: Address): BigInt {
    let result = super.call(
      "combinedWeightOf",
      "combinedWeightOf(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_combinedWeightOf(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "combinedWeightOf",
      "combinedWeightOf(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  controller_address(): Address {
    let result = super.call(
      "controller_address",
      "controller_address():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_controller_address(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "controller_address",
      "controller_address():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  earned(account: Address): VSTFRAX_GAUGE__earnedResult {
    let result = super.call("earned", "earned(address):(uint256,uint256)", [
      ethereum.Value.fromAddress(account)
    ]);

    return new VSTFRAX_GAUGE__earnedResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_earned(
    account: Address
  ): ethereum.CallResult<VSTFRAX_GAUGE__earnedResult> {
    let result = super.tryCall("earned", "earned(address):(uint256,uint256)", [
      ethereum.Value.fromAddress(account)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new VSTFRAX_GAUGE__earnedResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  fraxPerLPToken(): BigInt {
    let result = super.call("fraxPerLPToken", "fraxPerLPToken():(uint256)", []);

    return result[0].toBigInt();
  }

  try_fraxPerLPToken(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "fraxPerLPToken",
      "fraxPerLPToken():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  frax_address(): Address {
    let result = super.call("frax_address", "frax_address():(address)", []);

    return result[0].toAddress();
  }

  try_frax_address(): ethereum.CallResult<Address> {
    let result = super.tryCall("frax_address", "frax_address():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getReward(): VSTFRAX_GAUGE__getRewardResult {
    let result = super.call("getReward", "getReward():(uint256,uint256)", []);

    return new VSTFRAX_GAUGE__getRewardResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getReward(): ethereum.CallResult<VSTFRAX_GAUGE__getRewardResult> {
    let result = super.tryCall(
      "getReward",
      "getReward():(uint256,uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new VSTFRAX_GAUGE__getRewardResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  getRewardForDuration(): VSTFRAX_GAUGE__getRewardForDurationResult {
    let result = super.call(
      "getRewardForDuration",
      "getRewardForDuration():(uint256,uint256)",
      []
    );

    return new VSTFRAX_GAUGE__getRewardForDurationResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getRewardForDuration(): ethereum.CallResult<
    VSTFRAX_GAUGE__getRewardForDurationResult
  > {
    let result = super.tryCall(
      "getRewardForDuration",
      "getRewardForDuration():(uint256,uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new VSTFRAX_GAUGE__getRewardForDurationResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  isInitialized(): boolean {
    let result = super.call("isInitialized", "isInitialized():(bool)", []);

    return result[0].toBoolean();
  }

  try_isInitialized(): ethereum.CallResult<boolean> {
    let result = super.tryCall("isInitialized", "isInitialized():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  lastRewardPull(): BigInt {
    let result = super.call("lastRewardPull", "lastRewardPull():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lastRewardPull(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lastRewardPull",
      "lastRewardPull():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lastUpdateTime(): BigInt {
    let result = super.call("lastUpdateTime", "lastUpdateTime():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lastUpdateTime(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lastUpdateTime",
      "lastUpdateTime():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockMultiplier(secs: BigInt): BigInt {
    let result = super.call(
      "lockMultiplier",
      "lockMultiplier(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(secs)]
    );

    return result[0].toBigInt();
  }

  try_lockMultiplier(secs: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lockMultiplier",
      "lockMultiplier(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(secs)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lock_max_multiplier(): BigInt {
    let result = super.call(
      "lock_max_multiplier",
      "lock_max_multiplier():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_lock_max_multiplier(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lock_max_multiplier",
      "lock_max_multiplier():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lock_time_for_max_multiplier(): BigInt {
    let result = super.call(
      "lock_time_for_max_multiplier",
      "lock_time_for_max_multiplier():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_lock_time_for_max_multiplier(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lock_time_for_max_multiplier",
      "lock_time_for_max_multiplier():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lock_time_min(): BigInt {
    let result = super.call("lock_time_min", "lock_time_min():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lock_time_min(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lock_time_min",
      "lock_time_min():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockedLiquidityOf(account: Address): BigInt {
    let result = super.call(
      "lockedLiquidityOf",
      "lockedLiquidityOf(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_lockedLiquidityOf(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lockedLiquidityOf",
      "lockedLiquidityOf(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockedStakes(
    param0: Address,
    param1: BigInt
  ): VSTFRAX_GAUGE__lockedStakesResult {
    let result = super.call(
      "lockedStakes",
      "lockedStakes(address,uint256):(bytes32,uint256,uint256,uint256,uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return new VSTFRAX_GAUGE__lockedStakesResult(
      result[0].toBytes(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBigInt(),
      result[4].toBigInt()
    );
  }

  try_lockedStakes(
    param0: Address,
    param1: BigInt
  ): ethereum.CallResult<VSTFRAX_GAUGE__lockedStakesResult> {
    let result = super.tryCall(
      "lockedStakes",
      "lockedStakes(address,uint256):(bytes32,uint256,uint256,uint256,uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new VSTFRAX_GAUGE__lockedStakesResult(
        value[0].toBytes(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBigInt(),
        value[4].toBigInt()
      )
    );
  }

  lockedStakesOf(
    account: Address
  ): Array<VSTFRAX_GAUGE__lockedStakesOfResultValue0Struct> {
    let result = super.call(
      "lockedStakesOf",
      "lockedStakesOf(address):((bytes32,uint256,uint256,uint256,uint256)[])",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toTupleArray<
      VSTFRAX_GAUGE__lockedStakesOfResultValue0Struct
    >();
  }

  try_lockedStakesOf(
    account: Address
  ): ethereum.CallResult<
    Array<VSTFRAX_GAUGE__lockedStakesOfResultValue0Struct>
  > {
    let result = super.tryCall(
      "lockedStakesOf",
      "lockedStakesOf(address):((bytes32,uint256,uint256,uint256,uint256)[])",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<VSTFRAX_GAUGE__lockedStakesOfResultValue0Struct>()
    );
  }

  migrationsOn(): boolean {
    let result = super.call("migrationsOn", "migrationsOn():(bool)", []);

    return result[0].toBoolean();
  }

  try_migrationsOn(): ethereum.CallResult<boolean> {
    let result = super.tryCall("migrationsOn", "migrationsOn():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  minVeFXSForMaxBoost(account: Address): BigInt {
    let result = super.call(
      "minVeFXSForMaxBoost",
      "minVeFXSForMaxBoost(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_minVeFXSForMaxBoost(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "minVeFXSForMaxBoost",
      "minVeFXSForMaxBoost(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  nominatedOwner(): Address {
    let result = super.call("nominatedOwner", "nominatedOwner():(address)", []);

    return result[0].toAddress();
  }

  try_nominatedOwner(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "nominatedOwner",
      "nominatedOwner():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  periodFinish(): BigInt {
    let result = super.call("periodFinish", "periodFinish():(uint256)", []);

    return result[0].toBigInt();
  }

  try_periodFinish(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("periodFinish", "periodFinish():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardPerToken(): VSTFRAX_GAUGE__rewardPerTokenResult {
    let result = super.call(
      "rewardPerToken",
      "rewardPerToken():(uint256,uint256)",
      []
    );

    return new VSTFRAX_GAUGE__rewardPerTokenResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_rewardPerToken(): ethereum.CallResult<
    VSTFRAX_GAUGE__rewardPerTokenResult
  > {
    let result = super.tryCall(
      "rewardPerToken",
      "rewardPerToken():(uint256,uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new VSTFRAX_GAUGE__rewardPerTokenResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  rewardRate0(): BigInt {
    let result = super.call("rewardRate0", "rewardRate0():(uint256)", []);

    return result[0].toBigInt();
  }

  try_rewardRate0(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("rewardRate0", "rewardRate0():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardRate1(): BigInt {
    let result = super.call("rewardRate1", "rewardRate1():(uint256)", []);

    return result[0].toBigInt();
  }

  try_rewardRate1(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("rewardRate1", "rewardRate1():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewarder(): Address {
    let result = super.call("rewarder", "rewarder():(address)", []);

    return result[0].toAddress();
  }

  try_rewarder(): ethereum.CallResult<Address> {
    let result = super.tryCall("rewarder", "rewarder():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  rewards0(param0: Address): BigInt {
    let result = super.call("rewards0", "rewards0(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_rewards0(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("rewards0", "rewards0(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewards1(param0: Address): BigInt {
    let result = super.call("rewards1", "rewards1(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_rewards1(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("rewards1", "rewards1(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardsCollectionPaused(): boolean {
    let result = super.call(
      "rewardsCollectionPaused",
      "rewardsCollectionPaused():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_rewardsCollectionPaused(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "rewardsCollectionPaused",
      "rewardsCollectionPaused():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  rewardsDuration(): BigInt {
    let result = super.call(
      "rewardsDuration",
      "rewardsDuration():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_rewardsDuration(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "rewardsDuration",
      "rewardsDuration():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardsToken0(): Address {
    let result = super.call("rewardsToken0", "rewardsToken0():(address)", []);

    return result[0].toAddress();
  }

  try_rewardsToken0(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "rewardsToken0",
      "rewardsToken0():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  rewardsToken1(): Address {
    let result = super.call("rewardsToken1", "rewardsToken1():(address)", []);

    return result[0].toAddress();
  }

  try_rewardsToken1(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "rewardsToken1",
      "rewardsToken1():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  staker_allowed_migrators(param0: Address, param1: Address): boolean {
    let result = super.call(
      "staker_allowed_migrators",
      "staker_allowed_migrators(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBoolean();
  }

  try_staker_allowed_migrators(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "staker_allowed_migrators",
      "staker_allowed_migrators(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  stakesUnlocked(): boolean {
    let result = super.call("stakesUnlocked", "stakesUnlocked():(bool)", []);

    return result[0].toBoolean();
  }

  try_stakesUnlocked(): ethereum.CallResult<boolean> {
    let result = super.tryCall("stakesUnlocked", "stakesUnlocked():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  stakingPaused(): boolean {
    let result = super.call("stakingPaused", "stakingPaused():(bool)", []);

    return result[0].toBoolean();
  }

  try_stakingPaused(): ethereum.CallResult<boolean> {
    let result = super.tryCall("stakingPaused", "stakingPaused():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  stakingToken(): Address {
    let result = super.call("stakingToken", "stakingToken():(address)", []);

    return result[0].toAddress();
  }

  try_stakingToken(): ethereum.CallResult<Address> {
    let result = super.tryCall("stakingToken", "stakingToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  timelock_address(): Address {
    let result = super.call(
      "timelock_address",
      "timelock_address():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_timelock_address(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "timelock_address",
      "timelock_address():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  totalCombinedWeight(): BigInt {
    let result = super.call(
      "totalCombinedWeight",
      "totalCombinedWeight():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_totalCombinedWeight(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalCombinedWeight",
      "totalCombinedWeight():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalLiquidityLocked(): BigInt {
    let result = super.call(
      "totalLiquidityLocked",
      "totalLiquidityLocked():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_totalLiquidityLocked(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalLiquidityLocked",
      "totalLiquidityLocked():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  ttlRew0Owed(): BigInt {
    let result = super.call("ttlRew0Owed", "ttlRew0Owed():(uint256)", []);

    return result[0].toBigInt();
  }

  try_ttlRew0Owed(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("ttlRew0Owed", "ttlRew0Owed():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  ttlRew0Paid(): BigInt {
    let result = super.call("ttlRew0Paid", "ttlRew0Paid():(uint256)", []);

    return result[0].toBigInt();
  }

  try_ttlRew0Paid(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("ttlRew0Paid", "ttlRew0Paid():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  ttlRew1Owed(): BigInt {
    let result = super.call("ttlRew1Owed", "ttlRew1Owed():(uint256)", []);

    return result[0].toBigInt();
  }

  try_ttlRew1Owed(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("ttlRew1Owed", "ttlRew1Owed():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  ttlRew1Paid(): BigInt {
    let result = super.call("ttlRew1Paid", "ttlRew1Paid():(uint256)", []);

    return result[0].toBigInt();
  }

  try_ttlRew1Paid(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("ttlRew1Paid", "ttlRew1Paid():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  userRewardPerTokenPaid0(param0: Address): BigInt {
    let result = super.call(
      "userRewardPerTokenPaid0",
      "userRewardPerTokenPaid0(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_userRewardPerTokenPaid0(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "userRewardPerTokenPaid0",
      "userRewardPerTokenPaid0(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  userRewardPerTokenPaid1(param0: Address): BigInt {
    let result = super.call(
      "userRewardPerTokenPaid1",
      "userRewardPerTokenPaid1(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_userRewardPerTokenPaid1(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "userRewardPerTokenPaid1",
      "userRewardPerTokenPaid1(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  userStakedFrax(account: Address): BigInt {
    let result = super.call(
      "userStakedFrax",
      "userStakedFrax(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_userStakedFrax(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "userStakedFrax",
      "userStakedFrax(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  valid_migrators(param0: Address): boolean {
    let result = super.call(
      "valid_migrators",
      "valid_migrators(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBoolean();
  }

  try_valid_migrators(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "valid_migrators",
      "valid_migrators(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  veFXS(): Address {
    let result = super.call("veFXS", "veFXS():(address)", []);

    return result[0].toAddress();
  }

  try_veFXS(): ethereum.CallResult<Address> {
    let result = super.tryCall("veFXS", "veFXS():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  veFXSMultiplier(account: Address): BigInt {
    let result = super.call(
      "veFXSMultiplier",
      "veFXSMultiplier(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );

    return result[0].toBigInt();
  }

  try_veFXSMultiplier(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "veFXSMultiplier",
      "veFXSMultiplier(address):(uint256)",
      [ethereum.Value.fromAddress(account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  vefxs_max_multiplier(): BigInt {
    let result = super.call(
      "vefxs_max_multiplier",
      "vefxs_max_multiplier():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_vefxs_max_multiplier(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "vefxs_max_multiplier",
      "vefxs_max_multiplier():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  vefxs_per_frax_for_max_boost(): BigInt {
    let result = super.call(
      "vefxs_per_frax_for_max_boost",
      "vefxs_per_frax_for_max_boost():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_vefxs_per_frax_for_max_boost(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "vefxs_per_frax_for_max_boost",
      "vefxs_per_frax_for_max_boost():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  withdrawalsPaused(): boolean {
    let result = super.call(
      "withdrawalsPaused",
      "withdrawalsPaused():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_withdrawalsPaused(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "withdrawalsPaused",
      "withdrawalsPaused():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _bridge_token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _rewardsToken0(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _rewardsToken1(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get _stakingToken(): Address {
    return this._call.inputValues[4].value.toAddress();
  }

  get _frax_address(): Address {
    return this._call.inputValues[5].value.toAddress();
  }

  get _timelock_address(): Address {
    return this._call.inputValues[6].value.toAddress();
  }

  get _rewarder_address(): Address {
    return this._call.inputValues[7].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AcceptOwnershipCall extends ethereum.Call {
  get inputs(): AcceptOwnershipCall__Inputs {
    return new AcceptOwnershipCall__Inputs(this);
  }

  get outputs(): AcceptOwnershipCall__Outputs {
    return new AcceptOwnershipCall__Outputs(this);
  }
}

export class AcceptOwnershipCall__Inputs {
  _call: AcceptOwnershipCall;

  constructor(call: AcceptOwnershipCall) {
    this._call = call;
  }
}

export class AcceptOwnershipCall__Outputs {
  _call: AcceptOwnershipCall;

  constructor(call: AcceptOwnershipCall) {
    this._call = call;
  }
}

export class AddMigratorCall extends ethereum.Call {
  get inputs(): AddMigratorCall__Inputs {
    return new AddMigratorCall__Inputs(this);
  }

  get outputs(): AddMigratorCall__Outputs {
    return new AddMigratorCall__Outputs(this);
  }
}

export class AddMigratorCall__Inputs {
  _call: AddMigratorCall;

  constructor(call: AddMigratorCall) {
    this._call = call;
  }

  get migrator_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class AddMigratorCall__Outputs {
  _call: AddMigratorCall;

  constructor(call: AddMigratorCall) {
    this._call = call;
  }
}

export class GetRewardCall extends ethereum.Call {
  get inputs(): GetRewardCall__Inputs {
    return new GetRewardCall__Inputs(this);
  }

  get outputs(): GetRewardCall__Outputs {
    return new GetRewardCall__Outputs(this);
  }
}

export class GetRewardCall__Inputs {
  _call: GetRewardCall;

  constructor(call: GetRewardCall) {
    this._call = call;
  }
}

export class GetRewardCall__Outputs {
  _call: GetRewardCall;

  constructor(call: GetRewardCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get value1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class InitializeDefaultCall extends ethereum.Call {
  get inputs(): InitializeDefaultCall__Inputs {
    return new InitializeDefaultCall__Inputs(this);
  }

  get outputs(): InitializeDefaultCall__Outputs {
    return new InitializeDefaultCall__Outputs(this);
  }
}

export class InitializeDefaultCall__Inputs {
  _call: InitializeDefaultCall;

  constructor(call: InitializeDefaultCall) {
    this._call = call;
  }
}

export class InitializeDefaultCall__Outputs {
  _call: InitializeDefaultCall;

  constructor(call: InitializeDefaultCall) {
    this._call = call;
  }
}

export class LockAdditionalCall extends ethereum.Call {
  get inputs(): LockAdditionalCall__Inputs {
    return new LockAdditionalCall__Inputs(this);
  }

  get outputs(): LockAdditionalCall__Outputs {
    return new LockAdditionalCall__Outputs(this);
  }
}

export class LockAdditionalCall__Inputs {
  _call: LockAdditionalCall;

  constructor(call: LockAdditionalCall) {
    this._call = call;
  }

  get kek_id(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get addl_liq(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class LockAdditionalCall__Outputs {
  _call: LockAdditionalCall;

  constructor(call: LockAdditionalCall) {
    this._call = call;
  }
}

export class Migrator_stakeLocked_forCall extends ethereum.Call {
  get inputs(): Migrator_stakeLocked_forCall__Inputs {
    return new Migrator_stakeLocked_forCall__Inputs(this);
  }

  get outputs(): Migrator_stakeLocked_forCall__Outputs {
    return new Migrator_stakeLocked_forCall__Outputs(this);
  }
}

export class Migrator_stakeLocked_forCall__Inputs {
  _call: Migrator_stakeLocked_forCall;

  constructor(call: Migrator_stakeLocked_forCall) {
    this._call = call;
  }

  get staker_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get secs(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get start_timestamp(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class Migrator_stakeLocked_forCall__Outputs {
  _call: Migrator_stakeLocked_forCall;

  constructor(call: Migrator_stakeLocked_forCall) {
    this._call = call;
  }
}

export class Migrator_withdraw_lockedCall extends ethereum.Call {
  get inputs(): Migrator_withdraw_lockedCall__Inputs {
    return new Migrator_withdraw_lockedCall__Inputs(this);
  }

  get outputs(): Migrator_withdraw_lockedCall__Outputs {
    return new Migrator_withdraw_lockedCall__Outputs(this);
  }
}

export class Migrator_withdraw_lockedCall__Inputs {
  _call: Migrator_withdraw_lockedCall;

  constructor(call: Migrator_withdraw_lockedCall) {
    this._call = call;
  }

  get staker_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get kek_id(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class Migrator_withdraw_lockedCall__Outputs {
  _call: Migrator_withdraw_lockedCall;

  constructor(call: Migrator_withdraw_lockedCall) {
    this._call = call;
  }
}

export class NominateNewOwnerCall extends ethereum.Call {
  get inputs(): NominateNewOwnerCall__Inputs {
    return new NominateNewOwnerCall__Inputs(this);
  }

  get outputs(): NominateNewOwnerCall__Outputs {
    return new NominateNewOwnerCall__Outputs(this);
  }
}

export class NominateNewOwnerCall__Inputs {
  _call: NominateNewOwnerCall;

  constructor(call: NominateNewOwnerCall) {
    this._call = call;
  }

  get _owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class NominateNewOwnerCall__Outputs {
  _call: NominateNewOwnerCall;

  constructor(call: NominateNewOwnerCall) {
    this._call = call;
  }
}

export class RecoverERC20Call extends ethereum.Call {
  get inputs(): RecoverERC20Call__Inputs {
    return new RecoverERC20Call__Inputs(this);
  }

  get outputs(): RecoverERC20Call__Outputs {
    return new RecoverERC20Call__Outputs(this);
  }
}

export class RecoverERC20Call__Inputs {
  _call: RecoverERC20Call;

  constructor(call: RecoverERC20Call) {
    this._call = call;
  }

  get tokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokenAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RecoverERC20Call__Outputs {
  _call: RecoverERC20Call;

  constructor(call: RecoverERC20Call) {
    this._call = call;
  }
}

export class RemoveMigratorCall extends ethereum.Call {
  get inputs(): RemoveMigratorCall__Inputs {
    return new RemoveMigratorCall__Inputs(this);
  }

  get outputs(): RemoveMigratorCall__Outputs {
    return new RemoveMigratorCall__Outputs(this);
  }
}

export class RemoveMigratorCall__Inputs {
  _call: RemoveMigratorCall;

  constructor(call: RemoveMigratorCall) {
    this._call = call;
  }

  get migrator_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RemoveMigratorCall__Outputs {
  _call: RemoveMigratorCall;

  constructor(call: RemoveMigratorCall) {
    this._call = call;
  }
}

export class SetControllerCall extends ethereum.Call {
  get inputs(): SetControllerCall__Inputs {
    return new SetControllerCall__Inputs(this);
  }

  get outputs(): SetControllerCall__Outputs {
    return new SetControllerCall__Outputs(this);
  }
}

export class SetControllerCall__Inputs {
  _call: SetControllerCall;

  constructor(call: SetControllerCall) {
    this._call = call;
  }

  get _controller_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetControllerCall__Outputs {
  _call: SetControllerCall;

  constructor(call: SetControllerCall) {
    this._call = call;
  }
}

export class SetLockedStakeTimeForMinAndMaxMultiplierCall extends ethereum.Call {
  get inputs(): SetLockedStakeTimeForMinAndMaxMultiplierCall__Inputs {
    return new SetLockedStakeTimeForMinAndMaxMultiplierCall__Inputs(this);
  }

  get outputs(): SetLockedStakeTimeForMinAndMaxMultiplierCall__Outputs {
    return new SetLockedStakeTimeForMinAndMaxMultiplierCall__Outputs(this);
  }
}

export class SetLockedStakeTimeForMinAndMaxMultiplierCall__Inputs {
  _call: SetLockedStakeTimeForMinAndMaxMultiplierCall;

  constructor(call: SetLockedStakeTimeForMinAndMaxMultiplierCall) {
    this._call = call;
  }

  get _lock_time_for_max_multiplier(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _lock_time_min(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetLockedStakeTimeForMinAndMaxMultiplierCall__Outputs {
  _call: SetLockedStakeTimeForMinAndMaxMultiplierCall;

  constructor(call: SetLockedStakeTimeForMinAndMaxMultiplierCall) {
    this._call = call;
  }
}

export class SetMultipliersCall extends ethereum.Call {
  get inputs(): SetMultipliersCall__Inputs {
    return new SetMultipliersCall__Inputs(this);
  }

  get outputs(): SetMultipliersCall__Outputs {
    return new SetMultipliersCall__Outputs(this);
  }
}

export class SetMultipliersCall__Inputs {
  _call: SetMultipliersCall;

  constructor(call: SetMultipliersCall) {
    this._call = call;
  }

  get _lock_max_multiplier(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _vefxs_max_multiplier(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _vefxs_per_frax_for_max_boost(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class SetMultipliersCall__Outputs {
  _call: SetMultipliersCall;

  constructor(call: SetMultipliersCall) {
    this._call = call;
  }
}

export class SetTimelockCall extends ethereum.Call {
  get inputs(): SetTimelockCall__Inputs {
    return new SetTimelockCall__Inputs(this);
  }

  get outputs(): SetTimelockCall__Outputs {
    return new SetTimelockCall__Outputs(this);
  }
}

export class SetTimelockCall__Inputs {
  _call: SetTimelockCall;

  constructor(call: SetTimelockCall) {
    this._call = call;
  }

  get _new_timelock(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetTimelockCall__Outputs {
  _call: SetTimelockCall;

  constructor(call: SetTimelockCall) {
    this._call = call;
  }
}

export class SetVeFXSCall extends ethereum.Call {
  get inputs(): SetVeFXSCall__Inputs {
    return new SetVeFXSCall__Inputs(this);
  }

  get outputs(): SetVeFXSCall__Outputs {
    return new SetVeFXSCall__Outputs(this);
  }
}

export class SetVeFXSCall__Inputs {
  _call: SetVeFXSCall;

  constructor(call: SetVeFXSCall) {
    this._call = call;
  }

  get _vefxs_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetVeFXSCall__Outputs {
  _call: SetVeFXSCall;

  constructor(call: SetVeFXSCall) {
    this._call = call;
  }
}

export class StakeLockedCall extends ethereum.Call {
  get inputs(): StakeLockedCall__Inputs {
    return new StakeLockedCall__Inputs(this);
  }

  get outputs(): StakeLockedCall__Outputs {
    return new StakeLockedCall__Outputs(this);
  }
}

export class StakeLockedCall__Inputs {
  _call: StakeLockedCall;

  constructor(call: StakeLockedCall) {
    this._call = call;
  }

  get liquidity(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get secs(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class StakeLockedCall__Outputs {
  _call: StakeLockedCall;

  constructor(call: StakeLockedCall) {
    this._call = call;
  }
}

export class StakerAllowMigratorCall extends ethereum.Call {
  get inputs(): StakerAllowMigratorCall__Inputs {
    return new StakerAllowMigratorCall__Inputs(this);
  }

  get outputs(): StakerAllowMigratorCall__Outputs {
    return new StakerAllowMigratorCall__Outputs(this);
  }
}

export class StakerAllowMigratorCall__Inputs {
  _call: StakerAllowMigratorCall;

  constructor(call: StakerAllowMigratorCall) {
    this._call = call;
  }

  get migrator_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class StakerAllowMigratorCall__Outputs {
  _call: StakerAllowMigratorCall;

  constructor(call: StakerAllowMigratorCall) {
    this._call = call;
  }
}

export class StakerDisallowMigratorCall extends ethereum.Call {
  get inputs(): StakerDisallowMigratorCall__Inputs {
    return new StakerDisallowMigratorCall__Inputs(this);
  }

  get outputs(): StakerDisallowMigratorCall__Outputs {
    return new StakerDisallowMigratorCall__Outputs(this);
  }
}

export class StakerDisallowMigratorCall__Inputs {
  _call: StakerDisallowMigratorCall;

  constructor(call: StakerDisallowMigratorCall) {
    this._call = call;
  }

  get migrator_address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class StakerDisallowMigratorCall__Outputs {
  _call: StakerDisallowMigratorCall;

  constructor(call: StakerDisallowMigratorCall) {
    this._call = call;
  }
}

export class SweepBridgeTokensCall extends ethereum.Call {
  get inputs(): SweepBridgeTokensCall__Inputs {
    return new SweepBridgeTokensCall__Inputs(this);
  }

  get outputs(): SweepBridgeTokensCall__Outputs {
    return new SweepBridgeTokensCall__Outputs(this);
  }
}

export class SweepBridgeTokensCall__Inputs {
  _call: SweepBridgeTokensCall;

  constructor(call: SweepBridgeTokensCall) {
    this._call = call;
  }
}

export class SweepBridgeTokensCall__Outputs {
  _call: SweepBridgeTokensCall;

  constructor(call: SweepBridgeTokensCall) {
    this._call = call;
  }
}

export class SyncCall extends ethereum.Call {
  get inputs(): SyncCall__Inputs {
    return new SyncCall__Inputs(this);
  }

  get outputs(): SyncCall__Outputs {
    return new SyncCall__Outputs(this);
  }
}

export class SyncCall__Inputs {
  _call: SyncCall;

  constructor(call: SyncCall) {
    this._call = call;
  }
}

export class SyncCall__Outputs {
  _call: SyncCall;

  constructor(call: SyncCall) {
    this._call = call;
  }
}

export class ToggleMigrationsCall extends ethereum.Call {
  get inputs(): ToggleMigrationsCall__Inputs {
    return new ToggleMigrationsCall__Inputs(this);
  }

  get outputs(): ToggleMigrationsCall__Outputs {
    return new ToggleMigrationsCall__Outputs(this);
  }
}

export class ToggleMigrationsCall__Inputs {
  _call: ToggleMigrationsCall;

  constructor(call: ToggleMigrationsCall) {
    this._call = call;
  }
}

export class ToggleMigrationsCall__Outputs {
  _call: ToggleMigrationsCall;

  constructor(call: ToggleMigrationsCall) {
    this._call = call;
  }
}

export class ToggleRewardsCollectionCall extends ethereum.Call {
  get inputs(): ToggleRewardsCollectionCall__Inputs {
    return new ToggleRewardsCollectionCall__Inputs(this);
  }

  get outputs(): ToggleRewardsCollectionCall__Outputs {
    return new ToggleRewardsCollectionCall__Outputs(this);
  }
}

export class ToggleRewardsCollectionCall__Inputs {
  _call: ToggleRewardsCollectionCall;

  constructor(call: ToggleRewardsCollectionCall) {
    this._call = call;
  }
}

export class ToggleRewardsCollectionCall__Outputs {
  _call: ToggleRewardsCollectionCall;

  constructor(call: ToggleRewardsCollectionCall) {
    this._call = call;
  }
}

export class ToggleStakingCall extends ethereum.Call {
  get inputs(): ToggleStakingCall__Inputs {
    return new ToggleStakingCall__Inputs(this);
  }

  get outputs(): ToggleStakingCall__Outputs {
    return new ToggleStakingCall__Outputs(this);
  }
}

export class ToggleStakingCall__Inputs {
  _call: ToggleStakingCall;

  constructor(call: ToggleStakingCall) {
    this._call = call;
  }
}

export class ToggleStakingCall__Outputs {
  _call: ToggleStakingCall;

  constructor(call: ToggleStakingCall) {
    this._call = call;
  }
}

export class ToggleWithdrawalsCall extends ethereum.Call {
  get inputs(): ToggleWithdrawalsCall__Inputs {
    return new ToggleWithdrawalsCall__Inputs(this);
  }

  get outputs(): ToggleWithdrawalsCall__Outputs {
    return new ToggleWithdrawalsCall__Outputs(this);
  }
}

export class ToggleWithdrawalsCall__Inputs {
  _call: ToggleWithdrawalsCall;

  constructor(call: ToggleWithdrawalsCall) {
    this._call = call;
  }
}

export class ToggleWithdrawalsCall__Outputs {
  _call: ToggleWithdrawalsCall;

  constructor(call: ToggleWithdrawalsCall) {
    this._call = call;
  }
}

export class UnlockStakesCall extends ethereum.Call {
  get inputs(): UnlockStakesCall__Inputs {
    return new UnlockStakesCall__Inputs(this);
  }

  get outputs(): UnlockStakesCall__Outputs {
    return new UnlockStakesCall__Outputs(this);
  }
}

export class UnlockStakesCall__Inputs {
  _call: UnlockStakesCall;

  constructor(call: UnlockStakesCall) {
    this._call = call;
  }
}

export class UnlockStakesCall__Outputs {
  _call: UnlockStakesCall;

  constructor(call: UnlockStakesCall) {
    this._call = call;
  }
}

export class WithdrawLockedCall extends ethereum.Call {
  get inputs(): WithdrawLockedCall__Inputs {
    return new WithdrawLockedCall__Inputs(this);
  }

  get outputs(): WithdrawLockedCall__Outputs {
    return new WithdrawLockedCall__Outputs(this);
  }
}

export class WithdrawLockedCall__Inputs {
  _call: WithdrawLockedCall;

  constructor(call: WithdrawLockedCall) {
    this._call = call;
  }

  get kek_id(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class WithdrawLockedCall__Outputs {
  _call: WithdrawLockedCall;

  constructor(call: WithdrawLockedCall) {
    this._call = call;
  }
}
